// Generated by CoffeeScript 1.9.0
var JustLog, MIN_ROTATE_MS, Stream, colors, cwd, debug, defaultLogFile, error, events, fs, info, levels, mkdirp, moment, os, path, pattern, timeout, util, warn,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __hasProp = {}.hasOwnProperty,
  __slice = [].slice;

fs = require('fs');

path = require('path');

util = require('util');

events = require('events');

moment = require('moment');

mkdirp = require('mkdirp');

os = require('options-stream');

levels = require('./levels');

colors = require('./colors');

timeout = require('./timeout');

pattern = require('./pattern');

Stream = require('./stream');

info = levels.info, debug = levels.debug, warn = levels.warn, error = levels.error;

cwd = process.cwd();

defaultLogFile = "[" + cwd + "/logs/" + (path.basename(path.basename(process.argv[1], '.js'), '.coffee')) + "-]YYYY-MM-DD[.log]";

MIN_ROTATE_MS = 100;

JustLog = (function(_super) {
  __extends(JustLog, _super);


  /*
  /**
   * @param  {Object} options
   *  - {String} [encodeing='utf-8'],  log text encoding
   *  - file :
   *    - {Number} [level=error|warn], file log levels
   *    - {String} [pattern='file'],   log line pattern
   *    - {String} [mode='0664'],      log file mode
   *    - {String} [dir_mode='2775'],  log dir mode
   *    - {String} [path="[$CWD/logs/$MAIN_FILE_BASENAME-]YYYY-MM-DD[.log]"],   log file path pattern
   *  - stdio:
   *    - {Number}         [level=all],             file log levels
   *    - {String}         [pattern='color'],       log line pattern
   *    - {WritableStream} [stdout=process.stdout], info & debug output stream
   *    - {WritableStream} [stderr=process.stderr], warn & error output stream
   */

  function JustLog(options) {
    var k, v, _i, _len, _ref, _ref1;
    this.options = os({
      encoding: 'utf-8',
      placeholder: '-',
      file: {
        level: error | warn,
        pattern: 'file',
        path: defaultLogFile,
        mode: '0664',
        dir_mode: '2775',
        _watcher_timeout: 5007
      },
      stdio: {
        level: error | warn | debug | info,
        pattern: 'color',
        stdout: process.stdout,
        stderr: process.stderr
      },
      duration: 1000,
      bufferLength: 0
    }, options);
    if (this.options.file.level === 0) {
      this.options.file = false;
    }
    if (this.options.stdio.level === 0) {
      this.options.stdio = false;
    }
    _ref = levels.levels;
    for (k in _ref) {
      v = _ref[k];
      this[k.toUpperCase()] = v;
    }
    this.file = {
      path: this.options.file.path,
      stream: null,
      timer: null,
      opening: false,
      watcher: null,
      ino: null
    };
    this.closed = false;
    if (this.options.stdio) {
      this.stdout = this.options.stdio.stdout;
      this.stderr = this.options.stdio.stderr;
      this.options.stdio.render = pattern.compile(this.options.stdio.pattern, {
        placeholder: this.options.placeholder
      });
    }
    if (this.options.file) {
      this.options.file.render = pattern.compile(this.options.file.pattern, {
        placeholder: this.options.placeholder
      });
      this._initFile();
    }
    _ref1 = ['info', 'debug', 'warn', 'error'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      k = _ref1[_i];
      this[k] = this[k].bind(this);
    }
    this.lastCheckTime = this.lastFlushTime = new Date().getTime();
  }

  JustLog.prototype.emit = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    JustLog.__super__.emit.apply(this, args);
    JustLog.__super__.emit.apply(this, ['all'].concat(__slice.call(args)));
  };

  JustLog.prototype._checkFileRenamed = function(cb) {
    if (this.options.file === false || this.file.stream === null || this.file.opening === true) {
      cb(null, false);
      return;
    }
    return fs.stat(this.file.path, (function(_this) {
      return function(err, stat) {
        var prev;
        if (err) {
          if (err.code === 'ENOENT') {
            cb(null, true);
          } else {
            cb(err);
          }
          return;
        }
        prev = _this.file.ino;
        _this.file.ino = stat.ino;
        if (prev === null || prev === stat.ino) {
          cb(null, false);
        } else {
          cb(null, true);
        }
      };
    })(this));
  };

  JustLog.prototype._checkFile = function() {
    this._checkFileRenamed((function(_this) {
      return function(err, changed) {
        if (err) {
          return _this.emit(err);
        }
        if (changed === false) {
          return;
        }
        _this._closeStream();
        _this._newStream();
        _this.emit('rename', _this.file.path);
      };
    })(this));
  };

  JustLog.prototype._setFilePath = function() {
    var filePath;
    filePath = path.normalize(moment().format(this.options.file.path));
    if (path[0] === '/') {
      filePath = path.relative(cwd, filePath);
    }
    return this.file.path = filePath;
  };

  JustLog.prototype._newStream = function() {
    var err, filePath, stream;
    filePath = this.file.path;
    try {
      mkdirp.sync(path.dirname(filePath), this.options.file.dir_mode);
    } catch (_error) {
      err = _error;
      this.emit('error', err);
    }
    this.file.opening = true;
    stream = Stream({
      filePath: filePath,
      bufferLength: this.options.bufferLength
    });
    stream.on('error', this.emit.bind(this));
    stream.on('open', (function(_this) {
      return function() {
        _this.file.ino = null;
        return _this.file.opening = false;
      };
    })(this));
    return this.file.stream = stream;
  };

  JustLog.prototype._closeStream = function() {
    this.file.stream.end();
    this.file.stream = null;
  };

  JustLog.prototype._initFile = function() {
    this._setFilePath();
    this._newStream();
    return this._rotateFile();
  };

  JustLog.prototype._rotateFile = function() {
    var ms, prev;
    ms = timeout(this.options.file.path)[0];
    if (null === ms) {
      return;
    }
    if (ms <= MIN_ROTATE_MS) {
      ms = MIN_ROTATE_MS;
    }
    if (this.file.timer !== null) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    this.file.timer = setTimeout(this._rotateFile.bind(this), ms);
    process.nextTick((function(_this) {
      return function() {
        return _this.emit('timer', ms);
      };
    })(this));
    prev = this.file.path;
    this._setFilePath();
    if (prev !== this.file.path) {
      this._closeStream();
      this._newStream();
      this.emit('rotate', prev, this.file.path);
    }
  };

  JustLog.prototype._fileLog = function(msg, level) {
    var line;
    line = pattern.format(this.options.file.render, msg, level);
    return this.file.stream.write(line, this.options.encoding);
  };

  JustLog.prototype._stdioLog = function(msg, level) {
    var line;
    line = pattern.format(this.options.stdio.render, msg, level);
    return (level & (error | warn) ? this.stderr : this.stdout).write(line, this.options.encoding);
  };

  JustLog.prototype._log = function(msg, level) {
    if (msg.length !== 1 || typeof msg[0] !== 'object') {
      msg = util.format.apply(util, msg);
    } else {
      msg = msg[0];
    }
    if (this.options.file && (this.options.file.level & level)) {
      this._fileLog(msg, level);
    }
    if (this.options.stdio && (this.options.stdio.level & level)) {
      this._stdioLog(msg, level);
    }
    return this;
  };


  /*
  /**
   * send an info log
   * @param  {Mixed} msg... log info (run as console.log)
   * @return {JustLog}      return self object for chain call
   */

  JustLog.prototype.info = function() {
    var msg;
    msg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this._log(msg, info);
  };


  /*
  /**
   * send an debug log
   * @param  {Mixed} msg... log info (run as console.log)
   * @return {JustLog}      return self object for chain call
   */

  JustLog.prototype.debug = function() {
    var msg;
    msg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this._log(msg, debug);
  };


  /*
  /**
   * send an warn log
   * @param  {Mixed} msg... log info (run as console.log)
   * @return {JustLog}      return self object for chain call
   */

  JustLog.prototype.warn = function() {
    var msg;
    msg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this._log(msg, warn);
  };


  /*
  /**
   * send an error log
   * @param  {Mixed} msg... log info (run as console.log)
   * @return {JustLog}      return self object for chain call
   */

  JustLog.prototype.error = function() {
    var msg;
    msg = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this._log(msg, error);
  };


  /*
  /**
   * close log
   * @param  {Function} cb after close callback
   */

  JustLog.prototype.close = function(cb) {
    if (this.options.file === false || this.closed) {
      if (cb) {
        process.nextTick(cb);
      }
      return;
    }
    this.closed = true;
    if (cb && this.file.stream) {
      this.file.stream.on('close', cb);
    }
    this._closeStream();
    if (this.file.timer) {
      clearTimeout(this.file.timer);
      this.file.timer = null;
    }
  };

  JustLog.prototype.heartBeat = function(now) {
    if (now - this.lastFlushTime > this.options.duration && this.file.stream) {
      this.file.stream.flush();
      this.lastFlushTime = now;
    }
    if (now - this.lastCheckTime > this.options.file._watcher_timeout) {
      this._checkFile();
      return this.lastCheckTime = now;
    }
  };

  return JustLog;

})(events.EventEmitter);

module.exports = function(options) {
  return new JustLog(options);
};
